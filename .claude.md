# AI Accounting - Project Instructions for AI Agents

**Version:** 3.0  
**Last Updated:** February 12, 2026  
**Purpose:** Instructions for AI assistants working on this codebase  
**Change from v2.0:** Added Database Migration Rules, Agent Versioning Protocol, AI Prompt Standards, Rate Limiting Mandates, Financial Audit Trail, Context Limit Behaviour, Discovered Bug Protocol

---

## ğŸ¯ PROJECT OVERVIEW

This is an AI-powered accounting automation SaaS for UK accounting firms.

**What it does:**
- Uploads bank statements, receipts, invoices
- Extracts transaction data using Claude API
- Categorizes transactions automatically
- Creates double-entry journal entries
- Generates financial reports (P&L, Balance Sheet, VAT Return)
- Exports to accounting software (IRIS Kashflow, Xero, QuickBooks)

**Target users:** UK accountants and bookkeepers  
**Business model:** Â£800-1,200/month per accounting firm

---

## ğŸ“š DOCUMENTATION LOCATION

**ALL specifications are in `/docs` folder:**

```
/docs
â”œâ”€â”€ 01_BUSINESS_CASE.md          â†’ Market, pricing, financials
â”œâ”€â”€ 02_PRD.md                    â†’ Product requirements (63 user stories)
â”œâ”€â”€ 03_TECHNICAL_ARCHITECTURE.md â†’ Database, API, workers
â”œâ”€â”€ 04_ACCOUNTING_CALCULATIONS.md â†’ Financial logic (CRITICAL)
â”œâ”€â”€ 05_UI_UX_SPECIFICATION.md    â†’ All 30+ screen designs
â”œâ”€â”€ 06_TESTING_STRATEGY.md       â†’ Test cases
â”œâ”€â”€ 07_PERFORMANCE_MONITORING.md â†’ Monitoring setup
â”œâ”€â”€ 08_IMPLEMENTATION_PLAYBOOK.md â†’ Build sequence
â”œâ”€â”€ 09_PRODUCT_TREE.md           â†’ System structure
â”œâ”€â”€ 10_COMMAND_REFERENCE.md      â†’ Commands and tools
â”œâ”€â”€ 11_COMPLETE_USER_FLOW.md     â†’ Navigation and flows
â”œâ”€â”€ 12_SECURITY_COMPLIANCE.md    â†’ Security requirements (CRITICAL)
â”œâ”€â”€ 13_CRITICAL_FIXES.md         â†’ Required implementation fixes
â”œâ”€â”€ 14_ALIGNMENT_REPORT.md       â†’ Architecture alignment
â”œâ”€â”€ 15_FINAL_TECHNICAL_VALIDATION.md â†’ Validation results
â”œâ”€â”€ 16_ERROR_HANDLING_STANDARD.md â†’ Error handling patterns
â”œâ”€â”€ 17_DEPLOYMENT_CICD_GUIDE.md  â†’ Deployment pipeline
â””â”€â”€ REACT_ROUTER_SETUP.tsx       â†’ Navigation code
```

**ALWAYS reference these docs when building features. Never guess what a spec says â€” read it.**

---

## ğŸš¨ PRODUCTION SAFETY MANDATES â€” NON-NEGOTIABLE

These rules apply to EVERY file, EVERY feature, EVERY commit without exception.  
These are not suggestions. Violating any of these is a critical defect.

### 1. Data Integrity â€” Silent Corruption Prevention

```typescript
// âœ… MANDATORY: Every database write must be wrapped in a transaction
const { data, error } = await supabase.rpc('create_journal_entries', {
  entries: journalEntries
})

// âœ… MANDATORY: Confirm success before updating UI state
if (error) {
  throw new Error(`Write failed: ${error.message}`)
}
// Only update UI AFTER confirmed success
setTransactions(prev => [...prev, newTransaction])

// âœ… MANDATORY: Never assume a write succeeded
// Always check the response before proceeding
// Never fire-and-forget on database operations
```

### 2. Race Conditions â€” Atomic Operations

```typescript
// âœ… MANDATORY: Read-then-write operations must be atomic
// Use database-level functions for operations that read then modify

// âŒ NEVER DO THIS â€” race condition risk
const current = await getBalance(accountId)
const newBalance = current + amount
await updateBalance(accountId, newBalance)

// âœ… DO THIS â€” atomic at database level
await supabase.rpc('increment_balance', {
  account_id: accountId,
  amount: amount
})

// âœ… MANDATORY: Use optimistic locking for concurrent document processing
// Never assume sequential execution in async environments
// BullMQ jobs must use job locks to prevent duplicate processing
```

### 3. Security â€” Input Validation and Sanitisation

```typescript
// âœ… MANDATORY: Every input from any external source must be validated
// before it touches the database â€” no exceptions
// Sources include: user input, file uploads, API responses, AI extractions

import { z } from 'zod'

// Every API route must validate its request body
const ClientSchema = z.object({
  name: z.string().min(1).max(200),
  vatNumber: z.string().regex(/^GB\d{9}$/).optional(),
  email: z.string().email()
})

// âœ… MANDATORY: Parse and validate BEFORE any database operation
const validated = ClientSchema.parse(await c.req.json())

// âœ… MANDATORY: Validate AI extraction results before trusting them
// Claude API responses must be schema-validated, never used raw
try {
  const extracted = ExtractionSchema.parse(JSON.parse(aiResponse))
} catch (error) {
  // Log and flag for manual review â€” never silently discard
  logger.error('AI extraction failed schema validation', { 
    documentId, 
    error: error.message 
  })
  throw new ExtractionValidationError(documentId)
}
```

### 4. Authentication â€” Every Route Protected

```typescript
// âœ… MANDATORY: Every API route must verify authentication
// before executing ANY logic â€” no exceptions
// Authentication middleware is not optional on any route

// âœ… CORRECT: Auth check is first
app.get('/api/clients', authMiddleware, async (c) => {
  const userId = c.get('userId')
  const orgId = c.get('organizationId')
  // Now safe to proceed
})

// âŒ NEVER: Logic before auth check
app.get('/api/clients', async (c) => {
  const clients = await getClients()  // WRONG â€” no auth check
})

// âœ… MANDATORY: Extract and use organizationId from the JWT
// Never accept organizationId from the request body or query params
// Always use what is in the verified token
```

### 5. Sensitive Data â€” Never Logged, Never Exposed

```typescript
// âœ… MANDATORY: Never log sensitive data
// Log IDs and event types only â€” never content

// âŒ NEVER LOG
logger.info('User data', { user, password, token, financialData })

// âœ… CORRECT LOGGING
logger.info('User authenticated', { userId: user.id, event: 'login' })
logger.info('Document processed', { documentId, status: 'complete' })

// âœ… MANDATORY: Never expose sensitive fields in API responses
// âŒ WRONG
return c.json({ user })  // May include password hash, tokens

// âœ… CORRECT
return c.json({ 
  user: { 
    id: user.id, 
    email: user.email, 
    organizationId: user.organizationId 
  } 
})

// âœ… MANDATORY: Financial data in logs must be anonymised
// Log amounts as ranges or categories, never exact figures in debug logs
```

### 6. Resource Cleanup â€” No Memory Leaks

```typescript
// âœ… MANDATORY: Every subscription, listener, and connection
// opened must have explicit cleanup logic

// âœ… CORRECT: useEffect with cleanup
useEffect(() => {
  const subscription = supabase
    .channel('documents')
    .on('postgres_changes', handler)
    .subscribe()

  return () => {
    subscription.unsubscribe()  // MANDATORY cleanup
  }
}, [])

// âœ… MANDATORY: BullMQ workers must handle graceful shutdown
process.on('SIGTERM', async () => {
  await worker.close()
  await queue.close()
  await redis.quit()
})

// âŒ NEVER: Open a resource without a corresponding close
// Every connection opened = one close guaranteed
```

### 7. Multi-Tenancy â€” Security Boundary, Not a Filter

```typescript
// âœ… MANDATORY: organization_id is a SECURITY BOUNDARY
// A missing filter is a DATA BREACH, not a bug

// âœ… EVERY query touching business data must include organization filter
const { data } = await supabase
  .from('transactions')
  .select('*')
  .eq('organization_id', orgId)  // MANDATORY on every query

// âŒ CRITICAL SECURITY VIOLATION â€” never query without org filter
const { data } = await supabase
  .from('transactions')
  .select('*')  // This returns ALL organisations' data

// âœ… The organizationId must always come from the verified JWT
// Never from user input, request body, or query parameters
const orgId = c.get('organizationId')  // From authMiddleware only
```

### 8. Financial Accuracy â€” Decimal.js Always

```typescript
// âœ… MANDATORY: ALL financial calculations use Decimal.js
// No exceptions â€” ever â€” for any money arithmetic

import Decimal from 'decimal.js'

// âŒ NEVER â€” floating point errors corrupt financial records
const vat = amount * 0.20
const total = 10.1 + 20.2

// âœ… ALWAYS â€” exact decimal arithmetic
const vat = new Decimal(amount).times(0.20).toDecimalPlaces(2).toNumber()
const total = new Decimal(10.1).plus(20.2).toDecimalPlaces(2).toNumber()

// âœ… MANDATORY: Validate double-entry balance before every commit
const totalDebits = entries.reduce((sum, e) => 
  sum.plus(new Decimal(e.debit || 0)), new Decimal(0))
const totalCredits = entries.reduce((sum, e) => 
  sum.plus(new Decimal(e.credit || 0)), new Decimal(0))

if (totalDebits.minus(totalCredits).abs().greaterThan(0.01)) {
  throw new Error(`Unbalanced transaction! Debits: ${totalDebits}, Credits: ${totalCredits}`)
}
```

---

## ğŸ—„ï¸ DATABASE MIGRATION RULES â€” NON-NEGOTIABLE

Every schema change the agent makes must follow these rules without exception.  
A bad migration in a financial product can corrupt data that cannot be recovered.

### Safe vs Risky Migrations

```sql
-- âœ… SAFE â€” always allowed
ALTER TABLE transactions ADD COLUMN notes TEXT DEFAULT '';
CREATE INDEX idx_transactions_org ON transactions(organization_id);
CREATE TABLE new_feature (...);

-- âš ï¸ RISKY â€” requires the 3-step strategy below
ALTER TABLE transactions DROP COLUMN old_field;     -- Data loss risk
ALTER TABLE transactions RENAME COLUMN old TO new;  -- Breaking change
ALTER TABLE transactions ALTER COLUMN amount TYPE BIGINT; -- Data change
ALTER TABLE transactions ADD COLUMN required_field TEXT NOT NULL; -- Fails on existing rows
```

### The 3-Step Migration Strategy for Risky Changes

```
STEP 1: Deploy code that works with BOTH old and new schema
STEP 2: Run the migration
STEP 3: Deploy code that uses new schema only

Never skip steps. Never combine steps into one deployment.
```

### Mandatory Migration Rules

```sql
-- RULE 1: Every new column must have a default value
-- âŒ WRONG â€” fails for existing rows
ALTER TABLE transactions ADD COLUMN category TEXT NOT NULL;

-- âœ… CORRECT
ALTER TABLE transactions ADD COLUMN category TEXT NOT NULL DEFAULT 'uncategorised';

-- RULE 2: Every migration must have a rollback script
-- File: migrations/003_add_category_up.sql
ALTER TABLE transactions ADD COLUMN category TEXT NOT NULL DEFAULT 'uncategorised';

-- File: migrations/003_add_category_down.sql
ALTER TABLE transactions DROP COLUMN category;

-- RULE 3: Never drop a column without a feature flag first
-- Deprecate â†’ hide behind flag â†’ confirm unused â†’ then drop
-- Minimum 1 deployment cycle between deprecation and deletion

-- RULE 4: Test every migration locally before production
-- npx supabase db reset && npx supabase migration up
-- Verify data integrity after migration runs
```

### Agent Rule
Before writing any code that requires a new database column or table, state the migration required, confirm it follows these rules, and flag it explicitly so the project owner can run it before deployment.

---

## ğŸ”„ AGENT VERSIONING â€” HANDLING EXISTING CODE AND SPEC CHANGES

When the agent starts a new session or builds on top of previously generated code,  
these rules govern how it interacts with what already exists.

### Before Writing Any Code â€” Read First

```
MANDATORY SEQUENCE:
1. Read the relevant spec file
2. Read the existing code in the target files
3. Identify what already exists vs what needs to be added
4. Only then write new code

Never write into a file without first reading its current contents.
Never overwrite a working function without flagging the conflict explicitly.
```

### When Existing Code Conflicts With the Current Spec

```
If you find that existing code contradicts the current specification:

STOP. Do not silently overwrite.

State the conflict:
  CONFLICT DETECTED:
  File: [filename]
  Existing code: [what it currently does]
  Current spec says: [what the spec requires]
  Recommendation: [what should be done and why]
  Awaiting confirmation before modifying.

Wait for instruction. The project owner decides whether to:
  A) Update the code to match the spec
  B) Update the spec to match the existing code
  C) Keep both (versioned behaviour)
```

### Session Continuity

```
At the start of every new session:
1. Re-read .claude.md (this file)
2. Re-read the relevant spec for the current task
3. Run: git status â€” understand what was last changed
4. Do NOT rely on memory from previous sessions
5. Treat every session as if starting fresh from the specs

Memory from previous sessions is unreliable.
The specs and the codebase are the single source of truth.
```

---

## ğŸ¤– AI PROMPT STANDARDS â€” CLAUDE API CALLS

Every call to the Claude API within this codebase must follow this standard.  
Inconsistent prompting produces inconsistent financial data extraction â€” unacceptable.

### Mandatory Prompt Structure

```typescript
// Every Claude API call must follow this structure
const response = await claude.messages.create({
  model: 'claude-haiku-3-5-20241022',  // or Sonnet for complex tasks
  max_tokens: 1000,
  system: `You are a financial data extraction assistant for UK accounting firms.
You extract structured data from financial documents.
You ALWAYS return valid JSON matching the schema provided.
You NEVER invent data that is not present in the document.
If a field cannot be determined, return null for that field.
If the document is unreadable or not a financial document, return an error object.`,
  messages: [{
    role: 'user',
    content: `Extract transaction data from this document and return ONLY valid JSON.
No explanation. No markdown. No code blocks. Pure JSON only.

Required schema:
{
  "merchant": string | null,
  "amount": number | null,
  "date": string | null (ISO 8601),
  "vatAmount": number | null,
  "category": string | null,
  "confidence": "high" | "medium" | "low",
  "extractionError": string | null
}

Document content:
${documentContent}`
  }]
})
```

### Confidence Thresholds â€” When to Flag for Manual Review

```typescript
// Every AI extraction must be assessed for confidence
const extraction = await extractDocument(document)

if (extraction.confidence === 'low' || extraction.extractionError) {
  // Flag for manual review â€” never auto-process low confidence extractions
  await flagForManualReview(documentId, extraction.extractionError || 'Low confidence extraction')
  return { status: 'pending_review', documentId }
}

if (extraction.confidence === 'medium') {
  // Process but mark as requiring accountant verification
  await createTransaction({ ...extraction, requiresVerification: true })
  return { status: 'processed_unverified', documentId }
}

// High confidence â€” process normally
await createTransaction({ ...extraction, requiresVerification: false })
```

### Prompt Rules â€” What Every AI Call Must Do

```
ALWAYS include a system prompt defining the assistant's role
ALWAYS specify the exact JSON schema expected in the response
ALWAYS instruct the model to return null for missing fields, not to invent data
ALWAYS instruct the model to return pure JSON â€” no markdown, no explanation
ALWAYS handle malformed responses with schema validation (Zod)
NEVER use AI output directly in a database write without validation
NEVER call Claude API without a timeout (set max_tokens appropriately)
NEVER use Sonnet for tasks Haiku can handle â€” cost control is a business requirement
```

---

## âš¡ RATE LIMITING AND API QUOTA MANDATES

Every public route must be protected. Every external API call must be bounded.  
Unprotected routes are an attack surface. Unbounded AI calls are a cost catastrophe.

### Route Rate Limiting â€” Every Public Endpoint

```typescript
import { rateLimiter } from './middleware/rateLimiter'

// âœ… MANDATORY: All public routes must have rate limiting
// Authentication routes â€” strict limits to prevent brute force
app.post('/api/auth/login', rateLimiter({ max: 10, windowMs: 15 * 60 * 1000 }), handler)
app.post('/api/auth/register', rateLimiter({ max: 5, windowMs: 60 * 60 * 1000 }), handler)

// Document upload â€” limits per user per hour
app.post('/api/documents', authMiddleware, rateLimiter({ max: 50, windowMs: 60 * 60 * 1000, keyBy: 'userId' }), handler)

// Report generation â€” expensive operations
app.post('/api/reports', authMiddleware, rateLimiter({ max: 20, windowMs: 60 * 60 * 1000, keyBy: 'orgId' }), handler)

// Standard API routes
app.get('/api/clients', authMiddleware, rateLimiter({ max: 100, windowMs: 60 * 1000, keyBy: 'orgId' }), handler)
```

### BullMQ Worker Concurrency â€” Limit Parallel AI Calls

```typescript
// âœ… MANDATORY: All workers must have explicit concurrency limits
// Never create a worker without setting concurrency

const extractionWorker = new Worker('extraction', processDocument, {
  connection: redis,
  concurrency: 5,        // Max 5 parallel Claude API calls â€” cost control
  limiter: {
    max: 10,             // Max 10 jobs per duration
    duration: 1000       // Per second â€” respects Claude API rate limits
  }
})

const categorizationWorker = new Worker('categorization', categorizeTransaction, {
  connection: redis,
  concurrency: 10,       // Categorisation is cheaper than extraction
})

// âœ… MANDATORY: Every worker must have a job timeout
const job = await extractionQueue.add('extract', data, {
  attempts: 3,
  backoff: { type: 'exponential', delay: 2000 },
  removeOnComplete: 100,
  removeOnFail: 50,
  timeout: 30000         // 30 second max â€” prevents hung jobs
})
```

### Claude API Cost Controls

```typescript
// âœ… MANDATORY: Track API usage per organisation
// Log every Claude API call with token count for cost attribution
logger.info('Claude API call', {
  model: response.model,
  inputTokens: response.usage.input_tokens,
  outputTokens: response.usage.output_tokens,
  organisationId: orgId,
  documentId: documentId,
  workerType: 'extraction'
})

// âœ… MANDATORY: Implement monthly usage caps per organisation
// Check usage before processing â€” reject if cap exceeded
const monthlyUsage = await getMonthlyAIUsage(orgId)
if (monthlyUsage.documentsProcessed >= MONTHLY_AI_CAP) {
  throw new QuotaExceededError(orgId)
}
```

---

## ğŸ“‹ FINANCIAL AUDIT TRAIL â€” MANDATORY FOR ALL FINANCIAL DATA

This is not optional. UK accounting software handling client financial data  
must maintain a complete, immutable audit trail of every change to financial records.  
This is both a compliance requirement and a trust requirement.

### What Must Be Audited

Every write, update, or delete touching these tables must create an audit record:
- `transactions` â€” any categorisation, amount, or status change
- `journal_entries` â€” any creation or modification
- `accounts` â€” any balance update
- `vat_returns` â€” any creation, submission, or amendment
- `reports` â€” any generation or export

### Audit Record Structure

```typescript
interface AuditRecord {
  id: string                    // UUID
  organisationId: string        // Which firm
  userId: string                // Who made the change (from JWT)
  action: 'CREATE' | 'UPDATE' | 'DELETE' | 'EXPORT' | 'SUBMIT'
  entityType: string            // 'transaction' | 'journal_entry' | 'vat_return'
  entityId: string              // ID of the record changed
  previousValue: object | null  // Full previous state (null for CREATE)
  newValue: object | null       // Full new state (null for DELETE)
  ipAddress: string             // From request headers
  userAgent: string             // From request headers
  timestamp: Date               // Server time, not client time
  source: 'user' | 'ai_extraction' | 'system'  // What triggered the change
}
```

### Mandatory Audit Pattern

```typescript
// âœ… MANDATORY: Every financial write must be paired with an audit record
// Use a transaction to ensure both succeed or both fail together

async function categoriseTransaction(
  transactionId: string, 
  category: string,
  userId: string,
  orgId: string
) {
  // 1. Get current state for audit trail
  const { data: current } = await supabase
    .from('transactions')
    .select('*')
    .eq('id', transactionId)
    .single()

  // 2. Perform the update AND create audit record atomically
  const { error } = await supabase.rpc('update_transaction_with_audit', {
    transaction_id: transactionId,
    new_category: category,
    previous_state: current,
    user_id: userId,
    organisation_id: orgId,
    action: 'UPDATE',
    source: 'user'
  })

  if (error) throw new Error(`Categorisation failed: ${error.message}`)
}

// âŒ NEVER: Update financial data without audit record
await supabase.from('transactions').update({ category }).eq('id', id)
```

### Audit Trail Rules

```
Audit records are IMMUTABLE â€” never update or delete them
Audit records must be written in the SAME transaction as the data change
If the audit write fails, the data change must also fail â€” they are inseparable
Audit records must be retained for minimum 7 years (UK accounting requirement)
AI-generated changes must be flagged with source: 'ai_extraction'
Exports must be audited â€” who exported what data and when
```

---

## ğŸ“ CONTEXT LIMIT BEHAVIOUR â€” LONG TASK MANAGEMENT

When working on large features, the agent must manage its own context deliberately.  
Long sessions without checkpoints produce inconsistent code and missed requirements.

### Checkpoint Strategy for Large Features

```
For any feature that requires more than 5 files to be created or modified:

BEFORE STARTING:
1. List all files that need to be created or modified
2. Identify natural checkpoints (logical stopping points where code is working)
3. State the checkpoint plan before writing any code

AT EACH CHECKPOINT:
1. Ensure all code written so far compiles without errors
2. Ensure all code written so far satisfies its spec requirements
3. Re-read .claude.md and the relevant spec file
4. Only then continue to the next section

NEVER:
- Write 10 files in one session without a checkpoint
- Assume the spec is still in context after many file writes
- Continue building on broken or incomplete code
```

### Session Start Protocol

```
At the start of every new session, before any code is written:

1. State: "Starting new session. Re-reading specs."
2. Re-read this .claude.md file
3. Re-read the spec file for the current task
4. Run git status to understand current codebase state
5. State what you are about to build and which spec section covers it
6. Then begin

This takes 2 minutes and prevents hours of rework.
```

### When Approaching Context Limits

```
If you sense you are losing track of earlier requirements:

STOP writing new code.

1. Summarise what has been built so far
2. List what still needs to be built
3. Identify which spec sections are still outstanding
4. Commit what works
5. Start a fresh session for the remaining work

An incomplete feature committed at a checkpoint is better than
a complete feature with forgotten requirements buried inside it.
```

---

## ğŸ› DISCOVERED BUG PROTOCOL â€” FOUND WHILE BUILDING SOMETHING ELSE

When the agent discovers a problem in already-built code while working on a new feature,  
it must not ignore it and must not silently fix it without disclosure.

### The Protocol

```
If you discover a bug, safety mandate violation, or spec mismatch
in code that is NOT part of your current task:

STEP 1 â€” STOP and document the finding immediately:

  BUG DISCOVERED:
  Found in: [file and line number]
  Nature: [bug / safety mandate violation / spec mismatch]
  Severity: [CRITICAL / HIGH / MEDIUM / LOW]
  Description: [what is wrong]
  Impact: [what could go wrong in production]
  Proposed fix: [what should be done]
  Current task: [what you were building when you found this]

STEP 2 â€” Do NOT silently fix it.
  Fixing code outside your current task scope changes untested behaviour.
  The project owner must decide whether to fix it now or schedule it.

STEP 3 â€” Ask for instruction:
  "Do you want me to fix this now before continuing, or log it and proceed?"

STEP 4 â€” Act on the instruction received.
  If fixing now: fix, test, commit separately, then return to original task.
  If logging: add a TODO comment with the bug description and continue.
```

### Severity Classification

```
CRITICAL â€” Fix immediately, do not continue until resolved:
  - Safety mandate violation (missing auth, missing org filter, float arithmetic)
  - Data corruption risk
  - Security vulnerability
  - Broken accounting balance validation

HIGH â€” Flag and get instruction before proceeding:
  - Missing error handling on financial operations
  - Missing audit trail on financial data write
  - Race condition in data processing

MEDIUM â€” Log and continue, fix in next session:
  - Missing test coverage
  - Performance issue
  - Minor spec mismatch in non-financial UI

LOW â€” Add TODO comment and continue:
  - Code style issue
  - Minor refactor opportunity
  - Documentation gap
```

---

## âœ… SELF-VALIDATION PROTOCOL â€” BEFORE EVERY TASK IS COMPLETE

**Before marking any task as done, execute this checklist in full.**  
This is not optional. An incomplete task that passes this check is better  
than a complete task that fails it silently.

### Step 1 â€” Specification Check
Read the relevant spec file for the feature just built.  
For every business rule listed in the spec, verify it exists in the code.  
For every data field in the spec, verify it is present and correctly typed.  
For every user flow in the spec, verify the implementation matches it exactly.

### Step 2 â€” Safety Mandate Check
Confirm all 8 Production Safety Mandates above are satisfied in the new code:
- [ ] Database writes are transactional
- [ ] Read-then-write operations are atomic
- [ ] All inputs are validated with Zod schemas
- [ ] All routes have authentication middleware
- [ ] No sensitive data in logs or responses
- [ ] All opened resources have cleanup
- [ ] All queries include organization_id filter
- [ ] All financial calculations use Decimal.js

### Step 3 â€” Error Coverage Check
For every function written, verify:
- [ ] The happy path is implemented
- [ ] Every failure mode has an explicit handler
- [ ] Errors are logged with enough context to debug
- [ ] User-facing error messages are clear and do not expose internals
- [ ] No silent failures â€” every catch block either handles or re-throws

### Step 4 â€” Accounting Accuracy Check (if applicable)
If the task touches any financial calculation:
- [ ] Decimal.js is used for every arithmetic operation
- [ ] Double-entry validation runs before every transaction commit
- [ ] VAT calculations match rates in `/docs/04_ACCOUNTING_CALCULATIONS.md`
- [ ] Journal entry debit/credit balance is verified programmatically

### Step 5 â€” Final Output
Only when all four steps above are confirmed complete, mark the task as done.  
If any step reveals a gap, fix it before stopping.

---

## âš ï¸ UNCERTAINTY HANDLING â€” WHEN THE SPEC IS SILENT

If you encounter a scenario not covered by any specification document,  
**do not invent a solution silently.**

### Mandatory Protocol for Unspecified Scenarios

**Step 1 â€” Stop immediately.** Do not write code for an undocumented scenario.

**Step 2 â€” State the gap explicitly:**
```
GAP IDENTIFIED: [describe the exact scenario]
RELEVANT SPEC: [which doc you checked and what it says]
DECISION REQUIRED: [what choice needs to be made]
MY RECOMMENDATION: [what you would implement and why]
AWAITING CONFIRMATION before proceeding.
```

**Step 3 â€” Wait for confirmation** before writing any code for this scenario.

### Why This Matters
A flagged gap is a valuable discovery â€” it improves the specification.  
A silent assumption is a hidden defect that may not surface until production.  
The cost of asking is zero. The cost of a silent wrong assumption in  
financial software can be data corruption or regulatory non-compliance.

### Examples of Scenarios Requiring a Stop
- A transaction type not described in `04_ACCOUNTING_CALCULATIONS.md`
- A user role with permissions not defined in `02_PRD.md`
- An error state with no handling defined in `16_ERROR_HANDLING_STANDARD.md`
- A UI interaction not shown in `05_UI_UX_SPECIFICATION.md`
- An edge case in VAT calculation not covered by the accounting spec

---

## ğŸ—ï¸ TECH STACK

### **Frontend**
- **Framework:** React 18 with TypeScript
- **Styling:** Tailwind CSS
- **UI Components:** Shadcn UI (ALWAYS use these!)
- **State:** React Query (TanStack Query v5)
- **Routing:** React Router v6
- **Forms:** React Hook Form + Zod validation
- **HTTP:** Axios
- **Build:** Create React App

### **Backend**
- **Framework:** Node.js with Hono
- **Language:** TypeScript
- **Database:** PostgreSQL via Supabase
- **ORM:** Direct Supabase client (not Prisma)
- **Auth:** JWT tokens
- **Jobs:** BullMQ + Redis
- **AI:** Anthropic Claude API
- **Logging:** Winston

### **Infrastructure**
- **Database:** Supabase (PostgreSQL + Storage)
- **Backend Host:** Railway
- **Frontend Host:** Vercel
- **Monitoring:** Sentry + PostHog
- **Version Control:** Git + GitHub

---

## ğŸ¨ CODE STYLE & CONVENTIONS

### **General Rules**
```typescript
// âœ… DO: Use descriptive names
const clientsList = await getClients()

// âŒ DON'T: Use abbreviations
const clts = await getCl()

// âœ… DO: Use TypeScript types everywhere
interface Client {
  id: string
  name: string
  vatNumber: string
}

// âŒ DON'T: Use 'any' type
const client: any = {}
```

### **File Naming**
```
âœ… Components: PascalCase
   - LoginPage.tsx
   - DocumentsList.tsx
   - ClientForm.tsx

âœ… Utilities: camelCase
   - formatCurrency.ts
   - validateVAT.ts
   - supabaseClient.ts

âœ… Types: PascalCase with .types.ts
   - client.types.ts
   - document.types.ts

âœ… Tests: Same name + .test.ts
   - auth.test.ts
   - calculations.test.ts
```

### **Folder Structure**
```
frontend/src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/              â†’ Shadcn components (don't modify)
â”‚   â”œâ”€â”€ layout/          â†’ Header, Sidebar, MainLayout
â”‚   â””â”€â”€ features/        â†’ Feature-specific components
â”œâ”€â”€ pages/               â†’ Route components
â”‚   â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ documents/
â”‚   â”œâ”€â”€ clients/
â”‚   â””â”€â”€ reports/
â”œâ”€â”€ lib/                 â†’ Utilities
â”‚   â”œâ”€â”€ api.ts          â†’ Axios client
â”‚   â”œâ”€â”€ utils.ts        â†’ Helper functions
â”‚   â””â”€â”€ constants.ts    â†’ Constants
â”œâ”€â”€ hooks/               â†’ Custom React hooks
â”œâ”€â”€ types/               â†’ TypeScript types
â””â”€â”€ App.tsx             â†’ Router setup

backend/src/
â”œâ”€â”€ routes/              â†’ API routes (Hono)
â”‚   â”œâ”€â”€ auth.ts
â”‚   â”œâ”€â”€ documents.ts
â”‚   â”œâ”€â”€ clients.ts
â”‚   â””â”€â”€ reports.ts
â”œâ”€â”€ workers/             â†’ BullMQ background jobs
â”‚   â”œâ”€â”€ extraction.ts   â†’ Claude API extraction
â”‚   â”œâ”€â”€ categorization.ts
â”‚   â”œâ”€â”€ matching.ts
â”‚   â””â”€â”€ journalEntry.ts â†’ CRITICAL: Accounting logic
â”œâ”€â”€ lib/                 â†’ Shared utilities
â”‚   â”œâ”€â”€ supabase.ts     â†’ Database client
â”‚   â”œâ”€â”€ claude.ts       â†’ AI client
â”‚   â”œâ”€â”€ redis.ts        â†’ Queue client
â”‚   â””â”€â”€ validation.ts   â†’ Input validation
â”œâ”€â”€ types/               â†’ TypeScript types
â””â”€â”€ index.ts            â†’ Server entry point
```

---

## ğŸ¨ UI COMPONENT USAGE

### **ALWAYS Use Shadcn UI Components**

```tsx
// âœ… DO: Import from @/components/ui
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"

// âœ… DO: Use variants
<Button variant="default">Save</Button>
<Button variant="outline">Cancel</Button>
<Button variant="destructive">Delete</Button>

// âŒ DON'T: Create custom buttons from scratch
<button className="bg-blue-500...">Save</button>
```

### **Color Palette (Tailwind)**
```typescript
// Primary colors (blue)
bg-blue-600      â†’ Buttons, primary actions
text-blue-600    â†’ Links, accents

// Status colors
bg-green-100     â†’ Success background
text-green-700   â†’ Success text
bg-red-100       â†’ Error background
text-red-700     â†’ Error text
bg-orange-100    â†’ Warning background
text-orange-700  â†’ Warning text

// Neutrals
bg-slate-50      â†’ Page background
bg-white         â†’ Cards, panels
text-slate-900   â†’ Primary text
text-slate-600   â†’ Secondary text
border-slate-200 â†’ Borders
```

---

## ğŸ” AUTHENTICATION PATTERNS

### **Frontend Auth**
```typescript
// Check if user is logged in
const isAuthenticated = !!localStorage.getItem('token')

// Get current user
const token = localStorage.getItem('token')
const user = JSON.parse(localStorage.getItem('user') || '{}')

// Logout
localStorage.removeItem('token')
localStorage.removeItem('user')
navigate('/login')
```

### **Backend Auth**
```typescript
// âœ… MANDATORY: Protect ALL routes with middleware â€” no exceptions
import { authMiddleware } from './middleware/auth'

app.get('/api/clients', authMiddleware, async (c) => {
  const userId = c.get('userId')        // Set by middleware
  const orgId = c.get('organizationId') // Set by middleware
  // ... route logic
})
```

---

## ğŸ“Š DATABASE PATTERNS

### **Using Supabase Client**
```typescript
// âœ… DO: Use Supabase client
import { supabase } from '@/lib/supabase'

const { data, error } = await supabase
  .from('clients')
  .select('*')
  .eq('organization_id', orgId)  // MANDATORY â€” security boundary

// âœ… DO: Always handle errors â€” never ignore them
if (error) {
  logger.error('Database error', { operation: 'getClients', orgId, error: error.message })
  throw new Error('Failed to fetch clients')
}

// âŒ DON'T: Use raw SQL (use query builder)
// âŒ DON'T: Query without organization_id filter
```

---

## ğŸ¤– AI INTEGRATION PATTERNS

### **Claude API Usage**
```typescript
// âœ… DO: Use Haiku for simple tasks (80%)
import { claude } from '@/lib/claude'

const response = await claude.messages.create({
  model: 'claude-haiku-3-5-20241022',
  max_tokens: 1000,
  messages: [{
    role: 'user',
    content: 'Extract transaction data from this receipt...'
  }]
})

// âœ… DO: Use Sonnet for complex tasks (20%)
model: 'claude-sonnet-4-20250514'

// âœ… MANDATORY: Always validate AI responses before use
// Never trust raw AI output â€” always parse and schema-validate
try {
  const rawText = response.content[0].text
  const parsed = JSON.parse(rawText)
  const validated = ExtractionSchema.parse(parsed)  // Zod validation
  return validated
} catch (error) {
  logger.error('AI response validation failed', { documentId, error: error.message })
  throw new ExtractionValidationError(documentId)
}
```

---

## ğŸ’° ACCOUNTING RULES (CRITICAL!)

### **âš ï¸ CRITICAL: Financial Calculations**

**ALWAYS use Decimal.js for money calculations â€” this is a Production Safety Mandate.**

```typescript
// âŒ NEVER DO THIS - JavaScript floating point errors corrupt financial records
const vat = 100 * 0.20
const total = 10.1 + 20.2

// âœ… ALWAYS DO THIS
import Decimal from 'decimal.js'

function calculateVAT(amount: number, rate: number): number {
  return new Decimal(amount).times(rate).toDecimalPlaces(2).toNumber()
}

function addAmounts(...amounts: number[]): number {
  return amounts
    .reduce((sum, amt) => sum.plus(new Decimal(amt)), new Decimal(0))
    .toDecimalPlaces(2)
    .toNumber()
}
```

### **Double-Entry Bookkeeping**

**INCOME Transaction:**
```typescript
// Bank statement shows: +Â£100 from customer
// Debit Bank Account (1000) Â£100.00
// Credit Sales Revenue (4000) Â£100.00
// VALIDATION: Debits (100) = Credits (100) âœ“
```

**EXPENSE Transaction:**
```typescript
// Receipt: Â£50 office supplies (Â£41.67 net + Â£8.33 VAT)
// Debit Office Supplies (6100) Â£41.67
// Debit VAT Reclaimable (2110) Â£8.33
// Credit Bank Account (1000) Â£50.00
// VALIDATION: Debits (41.67 + 8.33 = 50.00) = Credits (50.00) âœ“
```

### **MANDATORY Balance Validation**
```typescript
// Run before EVERY transaction commit â€” no exceptions
const totalDebits = journalEntries
  .reduce((sum, entry) => sum.plus(new Decimal(entry.debit || 0)), new Decimal(0))
  .toDecimalPlaces(2)

const totalCredits = journalEntries
  .reduce((sum, entry) => sum.plus(new Decimal(entry.credit || 0)), new Decimal(0))
  .toDecimalPlaces(2)

if (totalDebits.minus(totalCredits).abs().greaterThan(0.01)) {
  throw new Error(`Unbalanced transaction! Debits: ${totalDebits}, Credits: ${totalCredits}`)
}
```

**SEE `/docs/04_ACCOUNTING_CALCULATIONS.md` FOR FULL DETAILS**  
**SEE `/docs/13_CRITICAL_FIXES.md` FOR REQUIRED IMPLEMENTATIONS**

---

## ğŸ§ª TESTING PATTERNS

### **Unit Tests (Vitest)**
```typescript
import { describe, it, expect } from 'vitest'
import { calculateVAT } from './calculations'

describe('VAT Calculation', () => {
  it('calculates 20% VAT correctly', () => {
    expect(calculateVAT(100, 0.20)).toBe(20)
  })
  
  it('handles zero-rated items', () => {
    expect(calculateVAT(100, 0)).toBe(0)
  })

  it('handles floating point edge cases correctly', () => {
    expect(calculateVAT(33.33, 0.20)).toBe(6.67)
  })
})
```

### **Integration Tests**
```typescript
describe('POST /api/clients', () => {
  it('creates a new client', async () => {
    const response = await request(app)
      .post('/api/clients')
      .set('Authorization', 'Bearer token')
      .send({ name: 'Test Client Ltd', vatNumber: 'GB123456789' })
    
    expect(response.status).toBe(201)
    expect(response.body.name).toBe('Test Client Ltd')
  })

  it('rejects requests without authentication', async () => {
    const response = await request(app)
      .post('/api/clients')
      .send({ name: 'Test Client Ltd' })
    
    expect(response.status).toBe(401)
  })
})
```

---

## ğŸš¨ ERROR HANDLING

### **Frontend**
```typescript
// âœ… DO: Use try-catch with user-friendly messages
// Never expose technical details in user-facing errors
try {
  await uploadDocument(file)
  toast.success('Document uploaded successfully')
} catch (error) {
  logger.error('Upload failed', { userId, fileName: file.name, error })
  toast.error('Failed to upload document. Please try again.')
}
```

### **Backend**
```typescript
// âœ… DO: Return appropriate status codes
// Log with context, respond without internals
app.post('/api/clients', authMiddleware, async (c) => {
  try {
    const body = ClientSchema.parse(await c.req.json())
    const client = await createClient(body)
    return c.json(client, 201)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return c.json({ error: 'Invalid input', details: error.errors }, 400)
    }
    logger.error('Error creating client', { error: error.message })
    return c.json({ error: 'Failed to create client' }, 500)
  }
})
```

**SEE `/docs/16_ERROR_HANDLING_STANDARD.md` FOR COMPLETE ERROR TAXONOMY**

---

## ğŸ”„ NAVIGATION PATTERNS

```typescript
import { useNavigate } from 'react-router-dom'

function MyComponent() {
  const navigate = useNavigate()
  navigate('/dashboard')
  navigate('/documents/upload')
  navigate(`/clients/${id}`)
  navigate(-1)
}
```

**SEE `/docs/REACT_ROUTER_SETUP.tsx` FOR COMPLETE SETUP**

---

## ğŸš« COMMON MISTAKES TO AVOID

```typescript
// âŒ DON'T: Use console.log in production
console.log('User data:', user)
// âœ… DO: Use Winston logger
logger.info('User logged in', { userId: user.id })

// âŒ DON'T: Hardcode values
const vatRate = 0.20
// âœ… DO: Use constants
import { UK_STANDARD_VAT_RATE } from '@/lib/constants'

// âŒ DON'T: Expose sensitive data in responses
return { user, password: user.password }
// âœ… DO: Exclude sensitive fields
return { user: { id: user.id, email: user.email } }

// âŒ DON'T: Skip error handling
const data = await fetchData()
// âœ… DO: Always handle errors
try {
  const data = await fetchData()
} catch (error) {
  handleError(error)
}

// âŒ DON'T: Use 'any' type
const client: any = {}
// âœ… DO: Define explicit types
const client: Client = {}

// âŒ DON'T: Query without org filter
supabase.from('transactions').select('*')
// âœ… DO: Always filter by organisation
supabase.from('transactions').select('*').eq('organization_id', orgId)

// âŒ DON'T: Use native floats for money
const total = price * quantity
// âœ… DO: Use Decimal.js
const total = new Decimal(price).times(quantity).toDecimalPlaces(2).toNumber()
```

---

## âœ… BEFORE COMMITTING CODE

**Complete ALL items. Do not commit with any item unchecked.**

### Operating Standards
- [ ] Code follows TypeScript patterns â€” no `any` types
- [ ] Uses Shadcn UI components â€” no custom-built UI primitives
- [ ] Proper error handling â€” no silent failures, no empty catch blocks
- [ ] Multi-tenancy filters on every data query (organization_id)
- [ ] Accounting logic validated with Decimal.js (if applicable)
- [ ] Tests written and passing
- [ ] No console.logs â€” Winston logger used throughout
- [ ] No hardcoded values â€” constants file used
- [ ] File naming conventions followed
- [ ] Implementation matches specification exactly

### Production Safety Mandates
- [ ] Database writes are transactional
- [ ] Read-then-write operations are atomic
- [ ] All external inputs validated with Zod
- [ ] All routes have authMiddleware
- [ ] No sensitive data in logs or API responses
- [ ] All subscriptions and listeners have cleanup
- [ ] All queries include organization_id filter
- [ ] All financial calculations use Decimal.js

### Self-Validation Protocol
- [ ] Relevant spec file read and implementation verified against it
- [ ] All business rules in spec are implemented in code
- [ ] All error cases in spec have corresponding handlers
- [ ] Accounting balance validation runs before every transaction commit

### Database Migration (if schema changed)
- [ ] New columns have default values
- [ ] Migration has a rollback script
- [ ] Migration tested locally before production
- [ ] No breaking changes deployed in a single step

### AI Prompt Standards (if Claude API called)
- [ ] System prompt defines assistant role
- [ ] JSON schema specified in prompt
- [ ] Response validated with Zod before use
- [ ] Confidence threshold checked â€” low confidence flagged for manual review
- [ ] Token usage logged for cost attribution

### Rate Limiting (if new route or worker added)
- [ ] Public routes have rate limiting middleware
- [ ] New workers have concurrency limits set
- [ ] New workers have job timeout set
- [ ] Claude API calls have monthly cap check

### Financial Audit Trail (if financial data written)
- [ ] Audit record created in same transaction as data change
- [ ] Previous state captured before update
- [ ] User ID, timestamp, and source recorded
- [ ] Audit write failure causes data write to fail

### Agent Versioning
- [ ] Existing code in target files was read before writing
- [ ] No working functions were overwritten without flagging
- [ ] Spec was re-read at start of this session
- [ ] Any spec vs code conflicts were flagged and resolved

---

## ğŸ“ REFERENCE ORDER

**Check these in order when building any feature:**

1. Relevant specification in `/docs` folder â€” read it first, always
2. `/docs/04_ACCOUNTING_CALCULATIONS.md` â€” if touching any financial logic
3. `/docs/12_SECURITY_COMPLIANCE.md` â€” if touching auth, data, or API routes
4. `/docs/16_ERROR_HANDLING_STANDARD.md` â€” for all error patterns
5. `/docs/08_IMPLEMENTATION_PLAYBOOK.md` â€” for build sequence guidance
6. `/docs/11_COMPLETE_USER_FLOW.md` â€” for navigation and UX flows
7. `/docs/10_COMMAND_REFERENCE.md` â€” for commands and tools

**If still unclear after checking all relevant docs: STOP and flag the gap.**  
Do not guess. Do not assume. Flag it.

---

**Version:** 3.0  
**Last updated:** February 12, 2026  
**Maintained by:** Project owner  
**For AI agents:** Claude Code CLI, Cursor, Continue, Copilot
